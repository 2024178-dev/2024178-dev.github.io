<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë°”ìš´ìŠ¤ ë³¼ ë§ˆìŠ¤í„°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";
        
        // ì—¬ê¸°ì— í”„ë¡œì íŠ¸ë³„ Firebase ì„¤ì • ê°ì²´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY", // ì‹¤ì œ í‚¤ë¡œ ëŒ€ì²´í•˜ì„¸ìš”
            authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_PROJECT_ID.appspot.com",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        };
        
        // Firebase ë³€ìˆ˜ë“¤ì„ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
        window.initializeApp = initializeApp;
        window.getFirestore = getFirestore;
        window.collection = collection;
        window.addDoc = addDoc;
        window.query = query;
        window.orderBy = orderBy;
        window.limit = limit;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.doc = doc;
    </script>
    <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* ë‹¤í¬ ëª¨ë“œ ë°°ê²½ */
            color: #e2e8f0;
        }
        .game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            border: 4px solid #4a5568;
            border-radius: 8px;
        }
        canvas {
            display: block;
            background-color: #2d3748; /* ê²Œì„ ë°°ê²½ */
        }
        .dimmer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* í´ë¦­ì„ ë°©í•´í•˜ì§€ ì•Šë„ë¡ */
        }
        .ui-box {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .leaderboard-list li {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px dashed #4a5568;
        }
        .leaderboard-list li:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body class="p-8">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-4xl font-bold text-center mb-6 text-indigo-400">ğŸ”´ ë°”ìš´ìŠ¤ ë³¼ ë§ˆìŠ¤í„°</h1>

        <div class="flex justify-between items-center mb-4 p-4 rounded-lg bg-gray-800 shadow-lg">
            <div id="score" class="text-xl font-bold text-yellow-400">ì ìˆ˜: 0</div>
            <div id="level" class="text-xl font-bold text-green-400">ë ˆë²¨: 1</div>
            <div id="lives" class="text-2xl">â¤ï¸â¤ï¸â¤ï¸</div>
            <div id="time" class="text-xl font-bold text-blue-400">ë‚¨ì€ ì‹œê°„: 00:00</div>
        </div>

        <div class="game-container mx-auto">
            <canvas id="gameCanvas" class="w-full"></canvas>
            <div id="dimmer" class="dimmer transition-colors duration-500"></div>

            <div id="startScreen" class="absolute inset-0 flex flex-col justify-center items-center bg-gray-900 bg-opacity-90 transition-opacity duration-300">
                <h2 class="text-5xl font-extrabold mb-6 text-indigo-400">GAME START</h2>
                <input type="text" id="playerNameInput" placeholder="í”Œë ˆì´ì–´ ì´ë¦„ (ë­í‚¹ ë“±ë¡ìš©)" class="p-3 mb-4 rounded-lg text-gray-900 w-64 text-center border-2 border-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-600">
                <button id="startGameButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-full shadow-xl transition duration-150">
                    ê²Œì„ ì‹œì‘ (ì‚¬ìš´ë“œ í™œì„±í™”)
                </button>
                <p class="mt-4 text-sm text-gray-400">WASD ë˜ëŠ” í™”ì‚´í‘œ í‚¤ë¡œ ì´ë™ ë° ì í”„</p>
                <p class="mt-2 text-sm text-gray-400">Ctrl/Cmd + S ë¡œ ë­í‚¹ ì €ì¥/ë¡œë“œ ê¸°ëŠ¥ í™œì„±í™”</p>
            </div>

            <div id="messageBox" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-8 bg-gray-800 border-4 border-yellow-500 rounded-lg shadow-2xl z-20 hidden text-center">
                <h3 id="messageTitle" class="text-3xl font-bold mb-4 text-yellow-400">PAUSE</h3>
                <p id="messageText" class="mb-6 text-lg">ê²Œì„ì„ ì¼ì‹œì •ì§€í–ˆìŠµë‹ˆë‹¤.</p>
                <button id="closeMessageButton" class="bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold py-2 px-6 rounded transition duration-150">
                    ê³„ì†í•˜ê¸° / ë‹¤ìŒ ë ˆë²¨ë¡œ
                </button>
            </div>
            
            <div id="endScreen" class="absolute inset-0 flex flex-col justify-center items-center bg-gray-900 bg-opacity-95 z-30 hidden text-center p-8">
                <h2 id="endTitle" class="text-6xl font-extrabold mb-4 text-red-500">ê²Œì„ ì˜¤ë²„!</h2>
                <p id="endMessage" class="text-xl mb-8 text-gray-300"></p>
                <div class="grid grid-cols-2 gap-4 text-left mb-8">
                    <p class="text-lg font-semibold text-green-400">ìµœì¢… ë ˆë²¨:</p> <p id="finalLevel" class="text-xl font-bold text-white">0</p>
                    <p class="text-lg font-semibold text-yellow-400">ì´ ì ìˆ˜:</p> <p id="finalScore" class="text-xl font-bold text-white">0</p>
                    <p class="text-lg font-semibold text-blue-400">ì´ ì‹œê°„:</p> <p id="finalTime" class="text-xl font-bold text-white">00:00</p>
                    <p class="text-lg font-extrabold text-red-400">ë­í‚¹ ì ìˆ˜:</p> <p id="finalRankingScore" class="text-2xl font-extrabold text-red-500">0</p>
                </div>
                <button id="restartGameButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-full shadow-xl transition duration-150">
                    ë‹¤ì‹œ ì‹œì‘
                </button>
            </div>
        </div>

        <div class="mt-8 p-6 bg-gray-800 rounded-lg shadow-lg">
            <h3 class="text-2xl font-bold mb-4 text-purple-400 text-center">ğŸ† ë°”ìš´ìŠ¤ë³¼ ë­í‚¹ (Top 10)</h3>
            <ol id="leaderboardList" class="leaderboard-list list-decimal pl-5 text-lg">
                <li>ë­í‚¹ ë¡œë“œ ëŒ€ê¸° ì¤‘...</li>
            </ol>
        </div>
    </div>

    <script type="module">
        // Firebase ë³€ìˆ˜ ê°€ì ¸ì˜¤ê¸°
        const { initializeApp, getFirestore, collection, addDoc, query, orderBy, limit, getDocs, deleteDoc, doc } = window;

        // --- Firebase ì„¤ì • ë° ë³€ìˆ˜ ---
        let db;
        let isAuthReady = false;
        
        const firebaseConfig = {
            // ì—¬ê¸°ì— í”„ë¡œì íŠ¸ë³„ Firebase ì„¤ì • ê°ì²´ë¥¼ ì…ë ¥í•˜ì„¸ìš”. (HTML <script type="module"> ë¶€ë¶„ê³¼ ë™ì¼)
            apiKey: "YOUR_API_KEY",
            authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_PROJECT_ID.appspot.com",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        };

        function initializeFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                console.error("Firebase API Keyë¥¼ ì„¤ì •í•´ ì£¼ì„¸ìš”!");
                leaderboardList.innerHTML = '<li>ê²½ê³ : Firebase í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë­í‚¹ ê¸°ëŠ¥ ë¹„í™œì„±í™”.</li>';
                return;
            }
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                isAuthReady = true;
                console.log("Firebase ì´ˆê¸°í™” ì„±ê³µ.");
                fetchLeaderboard(); // ë­í‚¹ ë¡œë“œ ì‹œë„
            } catch (error) {
                console.error("Firebase ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
                leaderboardList.innerHTML = '<li>ì˜¤ë¥˜: Firebase ì´ˆê¸°í™” ì‹¤íŒ¨.</li>';
            }
        }
        
        // --- ê²Œì„ ìƒìˆ˜ ë° ë³€ìˆ˜ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const dimmer = document.getElementById('dimmer');

        // UI ìš”ì†Œ
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const livesElement = document.getElementById('lives');
        const timeElement = document.getElementById('time');
        const startScreen = document.getElementById('startScreen');
        const startGameButton = document.getElementById('startGameButton');
        const playerNameInput = document.getElementById('playerNameInput');
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const closeMessageButton = document.getElementById('closeMessageButton');
        const endScreen = document.getElementById('endScreen');
        const endTitle = document.getElementById('endTitle');
        const endMessage = document.getElementById('endMessage');
        const finalLevel = document.getElementById('finalLevel');
        const finalScore = document.getElementById('finalScore');
        const finalTime = document.getElementById('finalTime');
        const finalRankingScore = document.getElementById('finalRankingScore');
        const restartGameButton = document.getElementById('restartGameButton');
        const leaderboardList = document.getElementById('leaderboardList');


        // ê²Œì„ ìƒíƒœ
        let isGameRunning = false;
        let isPaused = true;
        let isGameOver = false;
        let hasWon = false;
        let isDeathMessage = false;

        // í”Œë ˆì´ì–´ ì •ë³´
        let playerName = 'ìµëª…';
        let score = 0;
        let level = 1;
        let chancesLeft = 3; // ê¸°íšŒ (í•˜íŠ¸)
        let totalTime = 0; // ì „ì²´ ê²Œì„ ëˆ„ì  ì‹œê°„ (ms)

        // ì‹œê°„ ê´€ë ¨
        let lastUpdateTime = 0;
        let gameLoopId;
        const levelTimeLimit = 60000; // ë ˆë²¨ë‹¹ 60ì´ˆ (ms)
        let levelTimeRemaining = levelTimeLimit;
        let levelStartTime = 0;
        
        // ì¿¨íƒ€ì„
        let lastJumpTime = 0;
        const jumpCooldown = 300; // 0.3ì´ˆ ì¿¨íƒ€ì„
        let lastTeleportTime = 0;
        const teleportCooldown = 2000; // 2ì´ˆ ì¿¨íƒ€ì„

        // ë¬¼ë¦¬ ìƒìˆ˜
        const gravity = 0.5;
        const friction = 0.85; // ë•… ìœ„ ë§ˆì°°
        const airFriction = 0.99; // ê³µê¸° ì €í•­

        // í”Œë ˆì´ì–´ ì˜¤ë¸Œì íŠ¸
        const player = {
            x: 50,
            y: 50,
            vx: 0,
            vy: 0,
            radius: 10,
            speed: 5,
            jumpPower: -10,
            isGrounded: false,
            jumpsRemaining: 2 // ë”ë¸” ì í”„
        };

        // ê²Œì„ ìš”ì†Œ ë°°ì—´
        let platforms = [];
        let coins = [];
        let spikes = [];
        let teleporters = [];
        let exit = null;

        // ì…ë ¥ ìƒíƒœ
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false
        };

        // ì‹œê° íš¨ê³¼
        let hue = 0; // HSL ìƒ‰ìƒ íšŒì „ìš©
        let exitGlowIntensity = 0;
        let exitInactiveGlow = 0;

        // --- ì‚¬ìš´ë“œ ì„¤ì • (Tone.js) ---
        const jumpSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "square" },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.0, release: 0.1 }
        }).toDestination();
        
        const coinSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.001, decay: 0.05, sustain: 0.0, release: 0.05 }
        }).toDestination();
        
        const deathSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.01, decay: 0.5, sustain: 0.0, release: 0.5 }
        }).toDestination();

        // BGM (Simple Loop)
        const bgm = new Tone.MembraneSynth({
            "envelope": { "sustain": 0.8, "release": 0.05 },
            "volume": -15
        }).toDestination();
        
        function startBGM() {
            Tone.Transport.scheduleRepeat(time => {
                bgm.triggerAttackRelease("C2", "8n", time);
                bgm.triggerAttackRelease("G2", "8n", time + Tone.Time("8n").toSeconds());
            }, "4n");
            Tone.Transport.bpm.value = 120;
            Tone.Transport.start();
        }

        // --- ë ˆë²¨ ë°ì´í„° (Level 1ë¶€í„° Level 10ê¹Œì§€) ---
        const levels = {
            1: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 150, y: 350, width: 100, height: 20 },
                    { x: 300, y: 250, width: 150, height: 20 },
                    { x: 550, y: 150, width: 100, height: 20 }
                ],
                coins: [
                    { x: 200, y: 320, radius: 8 },
                    { x: 375, y: 220, radius: 8 },
                    { x: 600, y: 120, radius: 8 }
                ],
                spikes: [],
                teleporters: [],
                exit: { x: 700, y: 430, width: 50, height: 50 },
                dimmerOpacity: 0.1
            },
            // ë ˆë²¨ 2: ê°„ë‹¨í•œ ì í”„ ë„ì „
            2: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 200, y: 380, width: 100, height: 20 },
                    { x: 400, y: 280, width: 100, height: 20 },
                    { x: 600, y: 180, width: 100, height: 20 }
                ],
                coins: [
                    { x: 250, y: 350, radius: 8 },
                    { x: 450, y: 250, radius: 8 },
                    { x: 650, y: 150, radius: 8 }
                ],
                spikes: [{ x: 50, y: 460, width: 100, height: 20 }], // ì‹œì‘ ì§€ì  ê·¼ì²˜ì— ìŠ¤íŒŒì´í¬ ì¶”ê°€
                teleporters: [],
                exit: { x: 700, y: 130, width: 50, height: 50 },
                dimmerOpacity: 0.15
            },
            // ë ˆë²¨ 3: ì›€ì§ì´ëŠ” í”Œë«í¼ê³¼ ì í”„
            3: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 100, y: 380, width: 100, height: 20 },
                    { x: 300, y: 300, width: 150, height: 20 },
                    { x: 550, y: 220, width: 200, height: 20 }
                ],
                coins: [
                    { x: 150, y: 350, radius: 8 },
                    { x: 400, y: 270, radius: 8 },
                    { x: 650, y: 190, radius: 8 }
                ],
                spikes: [
                    { x: 200, y: 460, width: 100, height: 20 },
                    { x: 500, y: 460, width: 100, height: 20 }
                ],
                teleporters: [],
                exit: { x: 700, y: 430, width: 50, height: 50 },
                dimmerOpacity: 0.2
            },
            // ë ˆë²¨ 4: í…”ë ˆí¬í„° ë„ì…
            4: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 100, y: 350, width: 100, height: 20 },
                    { x: 600, y: 150, width: 150, height: 20 }
                ],
                coins: [
                    { x: 150, y: 320, radius: 8 },
                    { x: 675, y: 120, radius: 8 }
                ],
                spikes: [
                    { x: 250, y: 460, width: 100, height: 20 },
                    { x: 450, y: 460, width: 100, height: 20 }
                ],
                teleporters: [
                    { x: 50, y: 430, width: 50, height: 50, id: 1, targetId: 2 },
                    { x: 700, y: 430, width: 50, height: 50, id: 2, targetId: 1 }
                ],
                exit: { x: 375, y: 430, width: 50, height: 50 },
                dimmerOpacity: 0.25
            },
            // ë ˆë²¨ 5: ì´ì¤‘ í…”ë ˆí¬íŠ¸ ë° ì¢ì€ ì í”„
            5: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 150, y: 350, width: 50, height: 20 },
                    { x: 600, y: 250, width: 50, height: 20 },
                ],
                coins: [
                    { x: 175, y: 320, radius: 8 },
                    { x: 625, y: 220, radius: 8 },
                    { x: 400, y: 150, radius: 8 }
                ],
                spikes: [
                    { x: 250, y: 460, width: 300, height: 20 }
                ],
                teleporters: [
                    { x: 100, y: 430, width: 50, height: 50, id: 1, targetId: 2 },
                    { x: 650, y: 430, width: 50, height: 50, id: 2, targetId: 1 }
                ],
                exit: { x: 750, y: 50, width: 50, height: 50 },
                dimmerOpacity: 0.3
            },
            // ë ˆë²¨ 6: ì²œì¥ ìŠ¤íŒŒì´í¬
            6: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 200, y: 380, width: 100, height: 20 },
                    { x: 500, y: 280, width: 100, height: 20 },
                ],
                coins: [
                    { x: 250, y: 350, radius: 8 },
                    { x: 550, y: 250, radius: 8 }
                ],
                spikes: [
                    { x: 100, y: 460, width: 100, height: 20 },
                    { x: 350, y: 460, width: 100, height: 20 },
                    { x: 0, y: 0, width: 800, height: 20 }, // ì²œì¥ ìŠ¤íŒŒì´í¬
                ],
                teleporters: [],
                exit: { x: 700, y: 430, width: 50, height: 50 },
                dimmerOpacity: 0.35
            },
            // ë ˆë²¨ 7: ì¢ì€ í†µë¡œ
            7: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 200, y: 300, width: 400, height: 20 },
                ],
                coins: [
                    { x: 300, y: 270, radius: 8 },
                    { x: 500, y: 270, radius: 8 }
                ],
                spikes: [
                    { x: 50, y: 460, width: 100, height: 20 },
                    { x: 650, y: 460, width: 100, height: 20 },
                    { x: 250, y: 320, width: 300, height: 20 }, // ì¢ì€ í†µë¡œì˜ ì²œì¥ ìŠ¤íŒŒì´í¬
                ],
                teleporters: [
                    { x: 10, y: 430, width: 50, height: 50, id: 1, targetId: 2 },
                    { x: 740, y: 430, width: 50, height: 50, id: 2, targetId: 1 }
                ],
                exit: { x: 400, y: 430, width: 50, height: 50 },
                dimmerOpacity: 0.4
            },
            // ë ˆë²¨ 8: ë³µì¡í•œ í…”ë ˆí¬íŠ¸
            8: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 200, y: 250, width: 100, height: 20 },
                    { x: 500, y: 350, width: 100, height: 20 },
                ],
                coins: [
                    { x: 250, y: 220, radius: 8 },
                    { x: 550, y: 320, radius: 8 }
                ],
                spikes: [
                    { x: 350, y: 460, width: 100, height: 20 }
                ],
                teleporters: [
                    { x: 100, y: 430, width: 50, height: 50, id: 1, targetId: 3 },
                    { x: 700, y: 430, width: 50, height: 50, id: 2, targetId: 1 },
                    { x: 200, y: 200, width: 50, height: 50, id: 3, targetId: 2 }
                ],
                exit: { x: 400, y: 430, width: 50, height: 50 },
                dimmerOpacity: 0.45
            },
            // ë ˆë²¨ 9: ê·¹í•œì˜ ì í”„ì™€ ìŠ¤íŒŒì´í¬
            9: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 200, y: 380, width: 50, height: 20 },
                    { x: 400, y: 280, width: 50, height: 20 },
                    { x: 600, y: 180, width: 50, height: 20 },
                ],
                coins: [
                    { x: 225, y: 350, radius: 8 },
                    { x: 425, y: 250, radius: 8 },
                    { x: 625, y: 150, radius: 8 }
                ],
                spikes: [
                    { x: 100, y: 460, width: 100, height: 20 },
                    { x: 300, y: 460, width: 100, height: 20 },
                    { x: 500, y: 460, width: 100, height: 20 },
                    { x: 700, y: 460, width: 100, height: 20 }
                ],
                teleporters: [],
                exit: { x: 750, y: 130, width: 50, height: 50 },
                dimmerOpacity: 0.5
            },
            // ë ˆë²¨ 10: ìµœì¢… ë³´ìŠ¤ ë ˆë²¨ (ëª¨ë“  ìš”ì†Œì˜ ì¡°í•©)
            10: {
                startPos: { x: 50, y: 400 },
                platforms: [
                    { x: 0, y: 480, width: 800, height: 20 },
                    { x: 150, y: 300, width: 100, height: 20 },
                    { x: 550, y: 200, width: 100, height: 20 }
                ],
                coins: [
                    { x: 200, y: 270, radius: 8 },
                    { x: 600, y: 170, radius: 8 },
                    { x: 400, y: 100, radius: 8 }
                ],
                spikes: [
                    { x: 10, y: 460, width: 100, height: 20 },
                    { x: 280, y: 460, width: 100, height: 20 },
                    { x: 500, y: 460, width: 100, height: 20 },
                    { x: 700, y: 460, width: 100, height: 20 },
                    { x: 0, y: 0, width: 800, height: 20 } // ì²œì¥ ìŠ¤íŒŒì´í¬
                ],
                teleporters: [
                    { x: 400, y: 430, width: 50, height: 50, id: 1, targetId: 2 },
                    { x: 750, y: 430, width: 50, height: 50, id: 2, targetId: 1 }
                ],
                exit: { x: 400, y: 30, width: 50, height: 50 },
                dimmerOpacity: 0.6
            }
        };


        // --- ê²Œì„ ì—”ì§„ í•µì‹¬ í•¨ìˆ˜ ---

        function updateUI() {
            scoreElement.textContent = `ì ìˆ˜: ${score}`;
            levelElement.textContent = `ë ˆë²¨: ${level}`;
            let hearts = '';
            for (let i = 0; i < 3; i++) {
                if (chancesLeft > i) {
                    hearts += 'â¤ï¸';
                } else {
                    hearts += 'ğŸ–¤';
                }
            }
            livesElement.innerHTML = `${hearts}`;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay(ms) {
            const timeFormatted = formatTime(ms);
            timeElement.textContent = `ë‚¨ì€ ì‹œê°„: ${timeFormatted}`;
            if (ms < 10000) {
                timeElement.classList.add('bg-red-700', 'animate-pulse');
                deathSynth.triggerAttackRelease("C4", "8n");
            } else {
                timeElement.classList.remove('bg-red-700', 'animate-pulse');
            }
        }

        function calculateRankingScore(currentScore, finalTotalTime, finalLevel) {
            const totalSeconds = Math.floor(finalTotalTime / 1000);
            const timePenalty = totalSeconds * 10;
            const levelBonus = finalLevel * 1000;
            return Math.max(0, currentScore + levelBonus - timePenalty);
        }

        function loadLevel(isRetry = false) {
            const levelData = levels[level];
            if (!levelData) {
                hasWon = true;
                gameOver(true);
                return;
            }
            
            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
            canvas.width = 800;
            canvas.height = 500;

            // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            player.x = levelData.startPos.x;
            player.y = levelData.startPos.y;
            player.vx = 0;
            player.vy = 0;
            player.jumpsRemaining = 2;
            player.isGrounded = false;
            lastTeleportTime = 0; // ì¿¨íƒ€ì„ ì´ˆê¸°í™”
            
            // ê²Œì„ ìš”ì†Œ ë¡œë“œ
            platforms.length = 0;
            coins.length = 0;
            spikes.length = 0;
            teleporters.length = 0;
            platforms.push(...levelData.platforms);
            coins.push(...levelData.coins.map(c => ({...c, collected: false})));
            spikes.push(...levelData.spikes);
            teleporters.push(...levelData.teleporters);
            exit = levelData.exit;

            // UI ë° íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            levelElement.textContent = `ë ˆë²¨: ${level}`;
            dimmer.style.backgroundColor = `rgba(0, 0, 0, ${levelData.dimmerOpacity})`;

            if (!isRetry) {
                levelStartTime = performance.now();
                levelTimeRemaining = levelTimeLimit;
            }
            
            updateUI();
        }

        function checkCollision(player, rect) {
            const closestX = Math.max(rect.x, Math.min(player.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(player.y, rect.y + rect.height));
            const distanceX = player.x - closestX;
            const distanceY = player.y - closestY;
            
            const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
            return distanceSquared < (player.radius * player.radius);
        }

        function resolveCollision(player, rect) {
            const closestX = Math.max(rect.x, Math.min(player.x, rect.x + rect.width));
            const closestY = Math.max(rect.y, Math.min(player.y, rect.y + rect.height));
            
            const dx = player.x - closestX;
            const dy = player.y - closestY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < player.radius) {
                const overlap = player.radius - distance;
                const top = Math.abs(player.y + player.radius - rect.y);
                const bottom = Math.abs(rect.y + rect.height - player.y + player.radius);
                const left = Math.abs(player.x + player.radius - rect.x);
                const right = Math.abs(rect.x + rect.width - player.x + player.radius);
                
                const minOverlap = Math.min(top, bottom, left, right);
                
                if (minOverlap === top && player.vy >= 0) {
                    player.y = rect.y - player.radius;
                    player.vy = 0;
                    player.isGrounded = true;
                    player.jumpsRemaining = 2;
                    return;
                }
                if (minOverlap === bottom && player.vy <= 0) {
                    player.y = rect.y + rect.height + player.radius;
                    player.vy = 0;
                    return;
                }
                if (minOverlap === left) {
                    player.x = rect.x - player.radius;
                    player.vx = -player.vx * 0.5;
                    return;
                }
                if (minOverlap === right) {
                    player.x = rect.x + rect.width + player.radius;
                    player.vx = -player.vx * 0.5;
                    return;
                }
            }
        }

        function playerDeath(reason) {
            if (isPaused || isGameOver) return;

            chancesLeft--;
            deathSynth.triggerAttackRelease("C3", "0.5");

            const penalty = level * 50;
            score = Math.max(0, score - penalty);
            updateUI();
            
            isDeathMessage = true;
            isPaused = true;

            if (chancesLeft <= 0) {
                gameOver(false);
            } else {
                messageTitle.textContent = "ì‹¤íŒ¨!";
                messageText.textContent = `${reason}\n\nê¸°íšŒ ${chancesLeft}ë²ˆ ë‚¨ìŒ. ì ìˆ˜ ${penalty}ì  ì°¨ê°!`;
                messageBox.style.display = 'block';
            }
        }

        function gameOver(isWin) {
            isGameOver = true;
            isPaused = true;
            isGameRunning = false;
            Tone.Transport.stop();
            
            const finalRankingLevel = isWin ? 10 : level;
            const finalRankingScore = calculateRankingScore(score, totalTime, finalRankingLevel);
            
            showEndScreen(isWin, finalRankingScore, finalRankingLevel);
            
            if (isAuthReady) {
                saveScore(playerName, finalRankingScore, finalRankingLevel, totalTime);
            }
        }

        function showEndScreen(isWin, finalRankingScore, finalRankingLevel) {
            endTitle.textContent = isWin ? "ìµœì¢… ìŠ¹ë¦¬! ğŸ‘‘" : "ê²Œì„ ì˜¤ë²„! ğŸ’€";
            endMessage.textContent = isWin 
                ? "ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  ë ˆë²¨ì„ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤. ë‹¹ì‹ ì€ ìµœê³ ì˜ ë°”ìš´ìŠ¤ë³¼ ë§ˆìŠ¤í„°ì…ë‹ˆë‹¤!"
                : "ë‹¤ìŒ ë ˆë²¨ì— ë„ì „í•  ê¸°íšŒê°€ ë‹¤ì‹œ ì£¼ì–´ì§€ê¸°ë¥¼ ë°”ëë‹ˆë‹¤.";
                
            finalLevel.textContent = finalRankingLevel.toString();
            finalScore.textContent = score.toString();
            finalTime.textContent = formatTime(totalTime);
            finalRankingScore.textContent = finalRankingScore.toString();
            
            endScreen.style.display = 'block';
            fetchLeaderboard();
        }

        function update(dt) {
            // 1. ì…ë ¥ ì²˜ë¦¬ ë° ì†ë„ ê³„ì‚°
            if (keys.left) {
                player.vx = -player.speed;
            } else if (keys.right) {
                player.vx = player.speed;
            } else {
                player.vx *= player.isGrounded ? friction : airFriction;
            }

            if (Math.abs(player.vx) < 0.1) {
                player.vx = 0;
            }
            
            if (keys.up && (player.isGrounded || player.jumpsRemaining > 0)) {
                const currentTime = performance.now();
                if (currentTime - lastJumpTime > jumpCooldown) {
                    player.vy = player.jumpPower;
                    player.jumpsRemaining--;
                    player.isGrounded = false;
                    lastJumpTime = currentTime;
                    jumpSynth.triggerAttackRelease("C5", "8n");
                }
            }
            
            // 2. ë¬¼ë¦¬ ì ìš©
            player.vy += gravity;
            player.vy = Math.min(player.vy, 10);
            
            player.x += player.vx;
            player.y += player.vy;
            
            player.isGrounded = false;

            // 3. ì¶©ëŒ ê°ì§€ ë° í•´ê²°
            platforms.forEach(p => resolveCollision(player, p));
            
            if (player.x - player.radius < 0) {
                player.x = player.radius;
                player.vx = -player.vx * 0.5;
            }
            if (player.x + player.radius > canvas.width) {
                player.x = canvas.width - player.radius;
                player.vx = -player.vx * 0.5;
            }
            
            // 4. ê²Œì„ ìš”ì†Œ ìƒí˜¸ì‘ìš©
            
            // ì½”ì¸ ìˆ˜ì§‘
            for (let i = coins.length - 1; i >= 0; i--) {
                const c = coins[i];
                if (!c.collected && checkCollision({ ...player, radius: player.radius * 1.5 }, { x: c.x - c.radius, y: c.y - c.radius, width: c.radius * 2, height: c.radius * 2 })) {
                    coins.splice(i, 1);
                    score += 100;
                    coinSynth.triggerAttackRelease("C6", "16n");
                    updateUI();
                }
            }
            
            // ìŠ¤íŒŒì´í¬ ì¶©ëŒ
            spikes.forEach(s => {
                if (checkCollision(player, s)) {
                    playerDeath(`ë¶‰ì€ ê°€ì‹œì— ë‹¿ì•˜ìŠµë‹ˆë‹¤.`);
                }
            });

            // í…”ë ˆí¬í„° ì¶©ëŒ (ì¿¨íƒ€ì„ ì ìš©ë¨)
            if (level >= 4) {
                teleporters.forEach(t => {
                    if (checkCollision(player, t)) {
                        const currentTime = performance.now();
                        if (currentTime - lastTeleportTime < teleportCooldown) {
                            return; // ì¿¨íƒ€ì„ ì¤‘
                        }

                        const targetTeleporter = teleporters.find(tt => tt.id === t.targetId);
                        if (targetTeleporter) {
                            player.x = targetTeleporter.x + targetTeleporter.width / 2;
                            player.y = targetTeleporter.y - player.radius;
                            player.vy = 0;
                            jumpSynth.triggerAttackRelease("F5", "16n");
                            lastTeleportTime = currentTime; // ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
                        }
                    }
                });
            }
            
            // ì¶œêµ¬ ë„ë‹¬
            if (checkCollision(player, exit) && coins.length === 0) {
                if (level === 10) {
                    hasWon = true;
                    totalTime += (levelTimeLimit - levelTimeRemaining);
                    gameOver(true);
                } else {
                    isPaused = true;
                    isGameRunning = false;
                    
                    totalTime += (levelTimeLimit - levelTimeRemaining);
                    
                    messageTitle.textContent = `ë ˆë²¨ ${level} í´ë¦¬ì–´!`;
                    messageText.textContent = `ì¶•í•˜í•©ë‹ˆë‹¤! ë‹¤ìŒ ë ˆë²¨ë¡œ ì´ë™í•©ë‹ˆë‹¤.`;
                    messageBox.style.display = 'block';
                }
            }
            
            // ì¶”ë½ ê°ì§€
            if (player.y - player.radius > canvas.height) {
                playerDeath(`ë§µ ë°–ìœ¼ë¡œ ì¶”ë½í–ˆìŠµë‹ˆë‹¤.`);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // í”Œë«í¼
            platforms.forEach(p => {
                ctx.fillStyle = '#4a5568';
                ctx.fillRect(p.x, p.y, p.width, p.height);
                ctx.strokeStyle = '#a0aec0';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x, p.y, p.width, p.height);
            });
            
            // ì½”ì¸
            coins.forEach(c => {
                const time = performance.now() / 300;
                const glow = Math.sin(time) * 5 + 5;
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ffc837';
                ctx.shadowBlur = glow;
                ctx.shadowColor = '#ffc837';
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = '#fffbe0';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // í…”ë ˆí¬í„°
            if (level >= 4) {
                teleporters.forEach(t => {
                    const time = performance.now() / 500;
                    const glow = Math.sin(time * t.id) * 10 + 10;
                    
                    ctx.fillStyle = `hsl(240, 100%, 50%)`;
                    ctx.shadowBlur = glow;
                    ctx.shadowColor = `hsl(240, 100%, 70%)`;
                    ctx.fillRect(t.x, t.y, t.width, t.height);
                    
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = `hsl(240, 100%, 80%)`;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(t.x, t.y, t.width, t.height);
                });
            }

            // ìŠ¤íŒŒì´í¬
            spikes.forEach(s => {
                ctx.fillStyle = '#ff416c';
                ctx.beginPath();
                
                const numSpikes = Math.floor(s.width / 10);
                for (let i = 0; i < numSpikes; i++) {
                    const base = s.x + i * 10;
                    const spikeHeight = s.height; 
                    
                    // ìŠ¤íŒŒì´í¬ ë°©í–¥ ê²°ì • (y=0ì´ë©´ ì•„ë˜ë¡œ, y=480 ê·¼ì²˜ë©´ ìœ„ë¡œ)
                    if (s.y < 50) { // ì²œì¥ ìŠ¤íŒŒì´í¬ (ìœ„ì—ì„œ ì•„ë˜ë¡œ)
                        ctx.moveTo(base, s.y);
                        ctx.lineTo(base + 5, s.y + spikeHeight);
                        ctx.lineTo(base + 10, s.y);
                    } else { // ë°”ë‹¥ ìŠ¤íŒŒì´í¬ (ì•„ë˜ì—ì„œ ìœ„ë¡œ)
                        ctx.moveTo(base, s.y + s.height);
                        ctx.lineTo(base + 5, s.y);
                        ctx.lineTo(base + 10, s.y + s.height);
                    }
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff416c';
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // ì¶œêµ¬
            if (exit) {
                const isCompleted = coins.length === 0;
                
                if (isCompleted) {
                    exitGlowIntensity = Math.min(20, exitGlowIntensity + 0.5);
                    ctx.fillStyle = '#68d391';
                } else {
                    exitInactiveGlow = Math.min(5, exitInactiveGlow + 0.1);
                    ctx.fillStyle = '#4c7c59';
                }
                
                ctx.shadowBlur = isCompleted ? exitGlowIntensity : exitInactiveGlow;
                ctx.shadowColor = isCompleted ? '#68d391' : '#4c7c59';
                ctx.fillRect(exit.x, exit.y, exit.width, exit.height);
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#fff';
                ctx.font = '10px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(isCompleted ? "EXIT" : `COINS x ${coins.length}`, exit.x + exit.width / 2, exit.y + exit.height / 2 + 3);
            }

            // í”Œë ˆì´ì–´(ë³¼)
            hue = (hue + 1) % 360;
            const playerColor = `hsl(${hue}, 100%, 70%)`;
            
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = playerColor;
            ctx.shadowBlur = 15;
            ctx.shadowColor = playerColor;
            ctx.fill();
            ctx.shadowBlur = 0;

            if (player.jumpsRemaining > 0) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 3, 0, Math.PI * 2 * (player.jumpsRemaining / 2));
                ctx.stroke();
            }
        }

        function gameLoop(timestamp) {
            if (!lastUpdateTime) lastUpdateTime = timestamp;
            const dt = timestamp - lastUpdateTime;
            lastUpdateTime = timestamp;

            if (!isPaused && isGameRunning) {
                levelTimeRemaining -= dt;
                
                if (levelTimeRemaining <= 0) {
                    levelTimeRemaining = 0;
                    playerDeath(`ì‹œê°„ ì´ˆê³¼!`);
                }
                
                updateTimerDisplay(levelTimeRemaining);
                update(dt / 1000 * 60);
                draw();
            } else if (isGameRunning) {
                draw();
                updateTimerDisplay(levelTimeRemaining);
            }
            
            if (!isGameOver || isGameRunning) {
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        // --- Firebase í•¨ìˆ˜ ---

        async function fetchLeaderboard() {
            leaderboardList.innerHTML = '';
            if (!db || !isAuthReady) {
                leaderboardList.innerHTML = '<li>ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ëŒ€ê¸° ì¤‘...</li>';
                return;
            }

            try {
                const scoresRef = collection(db, "bounceball_scores");
                const q = query(scoresRef, orderBy("rankingScore", "desc"), orderBy("totalTime", "asc"), limit(10));
                
                const snapshot = await getDocs(q);
                const scores = [];
                snapshot.forEach(doc => {
                    scores.push(doc.data());
                });

                if (scores.length === 0) {
                    leaderboardList.innerHTML = '<li>ë“±ë¡ëœ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤.</li>';
                    return;
                }

                scores.forEach((score, index) => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>#${index + 1} ${score.playerName}</span>
                        <span class="font-mono">${score.rankingScore}ì  (${formatTime(score.totalTime)})</span>
                    `;
                    leaderboardList.appendChild(li);
                });

            } catch (error) {
                console.error("ë­í‚¹ ë¡œë“œ ì‹¤íŒ¨:", error);
                leaderboardList.innerHTML = '<li>ë­í‚¹ ë¡œë“œ ì˜¤ë¥˜ ë°œìƒ</li>';
            }
        }

        async function saveScore(playerName, rankingScore, finalLevel, totalTime) {
            if (!db || !isAuthReady) return;

            try {
                const scoresRef = collection(db, "bounceball_scores");
                
                // 1. í˜„ì¬ ë­í‚¹ ê°œìˆ˜ í™•ì¸ ë° ìµœí•˜ìœ„ ì ìˆ˜ í™•ì¸
                const qCount = query(scoresRef, orderBy("rankingScore", "desc"), limit(10));
                const snapshotCount = await getDocs(qCount);
                const currentScores = snapshotCount.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // ë­í‚¹ì´ 10ê°œ ë¯¸ë§Œì´ê±°ë‚˜, ìƒˆ ì ìˆ˜ê°€ ìµœí•˜ìœ„ ì ìˆ˜(10ìœ„)ë³´ë‹¤ ë†’ê±°ë‚˜ ê°™ìœ¼ë©´ ë“±ë¡ (ë™ì  ì‹œ ìµœë‹¨ ì‹œê°„ ìœ ë¦¬)
                const isEligible = currentScores.length < 10 || 
                                   rankingScore > currentScores[currentScores.length - 1].rankingScore ||
                                   (rankingScore === currentScores[currentScores.length - 1].rankingScore && totalTime < currentScores[currentScores.length - 1].totalTime);

                if (isEligible) {
                    // 2. ìƒˆ ì ìˆ˜ ì €ì¥
                    await addDoc(scoresRef, {
                        playerName: playerName,
                        rankingScore: rankingScore,
                        finalLevel: finalLevel,
                        totalTime: totalTime,
                        timestamp: new Date()
                    });
                    console.log("ì ìˆ˜ ì €ì¥ ì„±ê³µ:", rankingScore);

                    // 3. 10ê°œ ì´ˆê³¼ í•­ëª© ì œê±° (ì„ íƒ ì‚¬í•­: ë­í‚¹ ë“±ë¡ ì‹œ ì‹¤ì‹œê°„ìœ¼ë¡œ ìµœí•˜ìœ„ í•­ëª©ì„ ì‚­ì œí•˜ëŠ” ëŒ€ì‹ , ë“±ë¡ í›„ 10ê°œ ì´ˆê³¼ ì‹œ ì •ë¦¬)
                    const qCleanup = query(scoresRef, orderBy("rankingScore", "desc"), orderBy("totalTime", "asc"));
                    const snapshotCleanup = await getDocs(qCleanup);
                    
                    if (snapshotCleanup.docs.length > 10) {
                        // 11ë²ˆì§¸ ì´í›„ í•­ëª© ì‚­ì œ
                        for (let i = 10; i < snapshotCleanup.docs.length; i++) {
                            const docToDelete = snapshotCleanup.docs[i];
                            await deleteDoc(doc(db, "bounceball_scores", docToDelete.id));
                        }
                    }

                } else {
                    console.log("ìƒˆ ì ìˆ˜ê°€ ë­í‚¹ 10ìœ„ê¶Œì— ë“¤ì§€ ëª»í•´ ë“±ë¡ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
                }
                
            } catch (e) {
                console.error("ì ìˆ˜ ì €ì¥ ì‹¤íŒ¨:", e);
            }
        }

        // --- ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

        function resetGame() {
            score = 0;
            level = 1;
            chancesLeft = 3;
            totalTime = 0;
            isGameOver = false;
            hasWon = false;
            isDeathMessage = false;
            
            endScreen.style.display = 'none';
            startScreen.style.display = 'block';
            
            // í”Œë ˆì´ì–´ ì´ë¦„ ìœ ì§€
            playerName = playerNameInput.value.trim() || 'ìµëª…';

            // UI ì´ˆê¸°í™”
            updateUI();
            updateTimerDisplay(levelTimeLimit);
            
            // ê²Œì„ ë£¨í”„ ì •ì§€ (startScreenì—ì„œ ë‹¤ì‹œ ì‹œì‘)
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
        }
        
        startGameButton.addEventListener('click', () => {
            // Tone.js í™œì„±í™” (ë¸Œë¼ìš°ì € ì •ì±…)
            Tone.start(); 
            startBGM();

            playerName = playerNameInput.value.trim() || 'ìµëª…';
            startScreen.style.display = 'none';
            
            loadLevel();
            isPaused = false;
            isGameRunning = true;
            
            if (!gameLoopId) {
                lastUpdateTime = 0;
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        });

        closeMessageButton.addEventListener('click', () => {
            messageBox.style.display = 'none';
            if (isGameOver || hasWon) {
                // ê²Œì„ ì˜¤ë²„/ìŠ¹ë¦¬ í›„ì—ëŠ” ì—”ë“œ ìŠ¤í¬ë¦°ì—ì„œ ì²˜ë¦¬
            } else if (isDeathMessage) {
                 // ì£½ìŒ ë©”ì‹œì§€ í›„ í˜„ì¬ ë ˆë²¨ ì¬ì‹œì‘
                 loadLevel(true);
                 isPaused = false;
                 isGameRunning = true;
                 isDeathMessage = false;
            } else {
                // ë ˆë²¨ í´ë¦¬ì–´ í›„ ë‹¤ìŒ ë ˆë²¨
                level++;
                if (levels[level]) {
                    loadLevel();
                    isPaused = false;
                    isGameRunning = true;
                    exitGlowIntensity = 0;
                } else {
                    hasWon = true;
                    gameOver(true);
                }
            }
        });

        restartGameButton.addEventListener('click', () => {
            resetGame();
        });

        // í‚¤ ì…ë ¥ í•¸ë“¤ëŸ¬
        document.addEventListener('keydown', (e) => {
            if (isGameOver || startScreen.style.display !== 'none') return;
            
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                keys.left = true;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                keys.right = true;
            } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w' || e.key === ' ') {
                keys.up = true;
                e.preventDefault(); // ìŠ¤í˜ì´ìŠ¤ë°” ìŠ¤í¬ë¡¤ ë°©ì§€
            } else if (e.key === 'Escape' && isGameRunning && !isDeathMessage && messageBox.style.display === 'none') {
                 // ESCë¡œ ì¼ì‹œì •ì§€/ì¬ê°œ
                 isPaused = !isPaused;
                 if (isPaused) {
                    messageTitle.textContent = "ì¼ì‹œì •ì§€";
                    messageText.textContent = "ê²Œì„ì„ ì ì‹œ ë©ˆì·„ìŠµë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?";
                    messageBox.style.display = 'block';
                 } else {
                    messageBox.style.display = 'none';
                 }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                keys.left = false;
            } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                keys.right = false;
            } else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'w' || e.key === ' ') {
                keys.up = false;
            }
        });
        
        // --- ì´ˆê¸°í™” ë° ì‹¤í–‰ ---

        initializeFirebase();
        loadLevel(); // ì´ˆê¸° UI ë¡œë“œë¥¼ ìœ„í•´ í•œ ë²ˆ í˜¸ì¶œ
    </script>
</body>
</html>
